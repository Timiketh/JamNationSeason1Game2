<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>grille[0] = -1;

input = scr_safe_check(obj_game_input);

nbActions = 12;
nbRondes = 6;

current = 0;
currentNbActions = nbActions;
currentRonde = 0;

chanceExplosion = 0.5;

freeze = false;

hideBoard = false;

skipChangeTurn = false;

//obstacles[0] = obj_explosion;

obstacles[0] = obj_explosion;
obstacles[1] = obj_plus_tour;
obstacles[2] = obj_hide_board;
obstacles[3] = obj_detruire_obstacles
obstacles[4] = obj_switch_nodes;
obstacles[5] = obj_bouge_autre_perso;

controleAutrePerso = false;
tempsFreeze = room_speed*0.45;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>freeze = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!freeze)
{
    if (currentNbActions &gt; 0)
    {
        if (scr_execute(input.input2))
        {
            var theNode = collision_point(input.x, input.y, obj_node, false, false);
            if (theNode != noone &amp;&amp; theNode.active)
            {
                var gridDiffX = theNode.gridX - grille[current].perso.gridX;
                var gridDiffY = theNode.gridY - grille[current].perso.gridY;
                if string_count("blue", sprite_get_name(grille[current].perso.sprite_index)) &gt; 0{
                    if (gridDiffX &gt; 0){
                        grille[current].perso.sprite_index = spr_blueSide;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*1;
                    }else{
                        grille[current].perso.sprite_index = spr_blueSide;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*-1;
                    }
                    if(gridDiffY &gt; 0){
                        grille[current].perso.sprite_index = spr_blueFront;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*1;
                    }
                    if(gridDiffY &lt; 0){
                        grille[current].perso.sprite_index = spr_blueFront;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*1;
                    }
                }
                if string_count("brain", sprite_get_name(grille[current].perso.sprite_index)) &gt; 0{
                    if (gridDiffX &gt; 0){
                        grille[current].perso.sprite_index = spr_brainSide;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*1;
                    }else{
                        grille[current].perso.sprite_index = spr_brainSide;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*-1;
                    }
                    if(gridDiffY &gt; 0){
                        grille[current].perso.sprite_index = spr_brainFront;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*1;
                    }
                    if(gridDiffY &lt; 0){
                        grille[current].perso.sprite_index = spr_brainFront;
                        grille[current].perso.image_xscale = abs(grille[current].perso.image_xscale)*1;
                    }
                }
                grille[current].perso.moveToX = theNode.x;
                grille[current].perso.moveToY = theNode.y;
                grille[current].perso.gridX = theNode.gridX;
                grille[current].perso.gridY = theNode.gridY;
                if (controleAutrePerso)
                {
                    var thisIndex = 0;
                    if (current == 0)
                    {
                        thisIndex = 1;
                    }
                    var autrePersoX = grille[thisIndex].perso.gridX;
                    var autrePersoY = grille[thisIndex].perso.gridY;
                    var testX = autrePersoX + gridDiffX;
                    var testY = autrePersoY + gridDiffY;
                    if (testX &gt;= 0 &amp;&amp; testX &lt; grille[thisIndex].w &amp;&amp; testY &gt;= 0 &amp;&amp; testY &lt; grille[thisIndex].h)
                    {
                        var testNodeExists = grille[thisIndex].zeGrid[# testX, testY];
                        
                        if (exists(testNodeExists))
                        {
                            var canFollow = false;
                            if (gridDiffX &lt; 0)
                            {
                                canFollow = testNodeExists.connectR;
                            }
                            if (gridDiffX &gt; 0)
                            {
                                canFollow = testNodeExists.connectL;
                            }
                            if (gridDiffY &lt; 0)
                            {
                                canFollow = testNodeExists.connectD;
                            }
                            if (gridDiffY &gt; 0)
                            {
                                canFollow = testNodeExists.connectU;
                            }
                            if (canFollow)
                            {
                                grille[thisIndex].perso.moveToX = testNodeExists.x;
                                grille[thisIndex].perso.moveToY = testNodeExists.y;
                                grille[thisIndex].perso.gridX = testNodeExists.gridX;
                                grille[thisIndex].perso.gridY = testNodeExists.gridY;
                                with(obj_obstacle)
                                {
                                    if (node == testNodeExists)
                                    {
                                        scr_execute(action);
                                        instance_destroy();
                                        other.grille[thisIndex].perso.powerup = true;
                                    }
                                }
                            }
                        }
                    }
                    
                }
                currentNbActions -= 1;
                with(obj_node)
                {
                    active = false;
                }
                with(obj_obstacle)
                {
                    if (node == theNode)
                    {
                        scr_execute(action);
                        instance_destroy();
                        other.grille[other.current].perso.powerup = true;
                    }
                }
                if (currentNbActions &gt; 0)
                {
                    scr_defer(new_call(scr_set_node_active, theNode.gridX, theNode.gridY, grille[current]), tempsFreeze);
                }
                
                freeze = true;
                alarm[0] = tempsFreeze;
            }
        }
        if (scr_execute(input.input1))
        {
            var taille = array_length_1d(grille);
            var baseNode = grille[current].zeGrid[# grille[current].perso.gridX, grille[current].perso.gridY];
            currentNbActions -= 1;
            for (var i = 0; i &lt; taille; i++)
            {
                scr_defer(new_call(scr_switch_node, baseNode.gridX, baseNode.gridY, grille[i]), tempsFreeze);//;scr_switch_node(baseNode.gridX, baseNode.gridY, grille[i]);
            }
            
                
            if (controleAutrePerso)
            {
                var thisIndex = 0;
                if (current == 0)
                {
                    thisIndex = 1;
                }
                var otherPerso = grille[thisIndex].perso;
                var thisOtherNode = grille[thisIndex].zeGrid[# otherPerso.gridX, otherPerso.gridY];
                var taille = array_length_1d(grille);
                for (var i = 0; i &lt; taille; i++)
                {
                    scr_defer(new_call(scr_switch_node, thisOtherNode.gridX, thisOtherNode.gridY, grille[i]), tempsFreeze);
                }
                grille[thisIndex].perso.slam=true;
            }
            
            grille[current].perso.slam=true;
            freeze = true;
            alarm[0] = tempsFreeze;
        }
    }
    else
    {
        controleAutrePerso = false;
        with (obj_node)
        {
            visible = true;
        }
        with (obj_pont)
        {
            visible = true;
        }
        if (hideBoard)
        {
            scr_hide_board(grille[current]);
        }
        hideBoard = false;
        
        freeze = true;
        alarm[0] = tempsFreeze;
        if (current == 0)
        {
            current = 1;
        }
        else
        {
            current = 0;
            currentRonde++;
        }
        
        if (currentRonde &lt; nbRondes)
        {
            currentNbActions = nbActions;
            scr_set_node_active(grille[current].perso.gridX, grille[current].perso.gridY, grille[current]);
            
            with(obj_obstacle)
            {
                if (countdown &lt;= 0)
                {
                    scr_execute(doom);
                    instance_destroy();
                }
                else
                {
                    countdown--;
                }
            }
                
            repeat(5)
            {
                
                if (currentRonde + 2 &lt; nbRondes)
                {
                    var tailleObstacles = array_length_1d(obstacles);
                    
                    var tirage = random(1);
                    var tirageEffet = obstacles[irandom(tailleObstacles-1)];
                    if (tirage &lt; chanceExplosion &amp;&amp; instance_number(tirageEffet) &lt; 2)
                    {
                        var taille = array_length_1d(grille);
                        for (var j = 0; j &lt; taille; j++)
                        {
                            var ok = false;
                            var randX = 0;
                            var randY = 0;
                            var index = j;
                            var theNode = -1;
                            while (!ok)
                            {
                                randX = irandom(grille[index].w-1);
                                randY = irandom(grille[index].h-1);
                                theNode = grille[index].zeGrid[# randX, randY];
                                if (exists(theNode))
                                {
                                    ok = true;
                                }
                            }
                            
                            var doSpawn = true;
                            with (obj_obstacle)
                            {
                                if (node == theNode)
                                {
                                    doSpawn = false;
                                    break;
                                }
                            }
                            if (doSpawn)
                            {
                                var explo = instance_create(theNode.x, theNode.y, tirageEffet);
                                explo.action.argv[0] = theNode.gridX;
                                explo.action.argv[1] = theNode.gridY;
                                if (index == 0)
                                {
                                    explo.action.argv[2] = grille[1];
                                }
                                if (index == 1)
                                {
                                    explo.action.argv[2] = grille[0];
                                }
                                explo.node = theNode;
                                explo.grille = grille[index];
                                
                                if (explo.action.execute == scr_switch_nodes)
                                {
                                    explo.action.argv[0] = grille[0];
                                    explo.action.argv[1] = grille[1];
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }       
            }
            obj_debug.actif = true;
        }
        else
        {
            //ENDGAME
            alarm[0] = 0;
            freeze = true;
            with(obj_affiche_nb_tours)
            {
                fini = true;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var theNode = -1;
if (current == 0)
{
    theNode = grille[1].zeGrid[# grille[current].perso.gridX, grille[current].perso.gridY];
}
else
{
    theNode = grille[0].zeGrid[# grille[current].perso.gridX, grille[current].perso.gridY];    
}

if (exists(theNode) &amp;&amp; theNode.visible)
{
    var alphaTemp = draw_get_alpha();
    draw_set_alpha(0.7)
    draw_circle_colour(theNode.x, theNode.y, theNode.sprite_width*0.65, c_purple, c_purple, false);
    draw_set_alpha(alphaTemp);    
}

if (controleAutrePerso)
{
    var thisIndex = 0;
    if (current == 0)
    {
        thisIndex = 1;
    }
    var thisOtherNode = -1;
    var otherPerso = grille[thisIndex].perso;
    thisOtherNode = grille[current].zeGrid[# otherPerso.gridX, otherPerso.gridY];
    
    if (exists(thisOtherNode) &amp;&amp; thisOtherNode.visible)
    {
        var alphaTemp = draw_get_alpha();
        draw_set_alpha(0.7)
        draw_circle_colour(thisOtherNode.x, thisOtherNode.y, thisOtherNode.sprite_width*0.65, c_purple, c_purple, false);
        draw_set_alpha(alphaTemp);    
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
